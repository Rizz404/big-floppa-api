Object.defineProperty(exports,"__esModule",{value:true});Object.defineProperty(exports,"default",{enumerable:true,get:function(){return _default}});const _bcrypt=_interop_require_default(require("bcrypt"));const _datasource=_interop_require_default(require("../config/data-source"));const _getErrorMessage=_interop_require_default(require("../utils/getErrorMessage"));const _Userentity=require("../entity/User.entity");const _Profileentity=require("../entity/Profile.entity");const _paginatedResponse=_interop_require_default(require("../utils/paginatedResponse"));function _interop_require_default(obj){return obj&&obj.__esModule?obj:{default:obj}}class UserController{userRepository=_datasource.default.getRepository(_Userentity.User);profileRepository=_datasource.default.getRepository(_Profileentity.Profile);createUser=async(req,res)=>{try{const{password,...rest}=req.body;const usersCount=await this.userRepository.count();const salt=await _bcrypt.default.genSalt();const hashedPassword=await _bcrypt.default.hash(password,salt);const newUser=this.userRepository.create({...rest,password:hashedPassword});if(usersCount===0){newUser.role=_Userentity.UserRole.ADMIN}const savedUser=await this.userRepository.save(newUser);const newProfile=this.profileRepository.create({user:savedUser});await this.profileRepository.save(newProfile);res.status(201).json({message:"User created successfully",data:newUser})}catch(error){res.status(500).json({message:(0,_getErrorMessage.default)(error)})}};getUsers=async(req,res)=>{try{const{page="1",limit="10",order,role,isOauth,isVerified}=req.query;const skip=(+page-1)*+limit;const totalData=await this.userRepository.count();const users=await this.userRepository.find({where:{role,isOauth,isVerified},take:+limit,skip:skip,relations:{profile:true},order:{createdAt:order}});const response=(0,_paginatedResponse.default)(users,+page,+limit,totalData);res.json(response)}catch(error){res.status(500).json({message:(0,_getErrorMessage.default)(error)})}};getUserById=async(req,res)=>{try{const{userId}=req.params;const user=await this.userRepository.findOne({where:{id:userId},relations:{profile:true}});if(!user){return res.status(404).json({message:"User not found"})}res.json(user)}catch(error){res.status(500).json({message:(0,_getErrorMessage.default)(error)})}};updateUserProfile=async(req,res)=>{try{const{id,profile}=req.user;const{username,email,firstname,lastname,profilePicture,gender,age,phoneNumber,bio}=req.body;await this.userRepository.update(id,{username,email});await this.profileRepository.update(profile.id,{firstname,lastname,profilePicture,gender,age,phoneNumber,bio});const updatedUser=await this.userRepository.findOne({where:{id},relations:{profile:true}});res.json({message:"User and profile updated",data:updatedUser})}catch(error){res.status(500).json({message:(0,_getErrorMessage.default)(error)})}};updateUserRole=async(req,res)=>{try{const{userId}=req.params;const{role}=req.body;await this.userRepository.update(userId,{role});const user=await this.userRepository.findOne({where:{id:userId}});res.json({message:"User role updated",data:user})}catch(error){res.status(500).json({message:(0,_getErrorMessage.default)(error)})}};verifiedUser=async(req,res)=>{try{const{userId}=req.params;const user=await this.userRepository.findOne({where:{id:userId}});if(user?.isVerified){await this.userRepository.update(userId,{isVerified:false})}else{await this.userRepository.update(userId,{isVerified:true})}const updatedUser=await this.userRepository.findOne({where:{id:userId}});res.json({message:"User verify updated",data:updatedUser})}catch(error){res.status(500).json({message:(0,_getErrorMessage.default)(error)})}};updateUserPassword=async(req,res)=>{try{const{userId}=req.params;const{oldPassword,newPassword}=req.body;const user=await this.userRepository.findOne({where:{id:userId}});if(!user){return res.status(404).json({message:"User not found"})}if(user.isOauth){return res.status(404).json({message:"Oauth doesn't include password"})}const isPasswordMatch=await _bcrypt.default.compare(oldPassword,user.password);if(!isPasswordMatch){return res.status(400).json({message:"Password not match"})}const salt=await _bcrypt.default.genSalt();const hashedPassword=await _bcrypt.default.hash(newPassword,salt);await this.userRepository.update(userId,{password:hashedPassword});const updatedUser=await this.userRepository.findOne({where:{id:userId}});res.json({message:"User updated",data:updatedUser})}catch(error){res.status(500).json({message:(0,_getErrorMessage.default)(error)})}};deleteUserById=async(req,res)=>{try{const{userId}=req.params;const deletedUser=await this.userRepository.delete(userId);res.json({message:"User deleted",data:deletedUser})}catch(error){res.status(500).json({message:(0,_getErrorMessage.default)(error)})}}}const _default=new UserController;
//# sourceMappingURL=user.controller.js.map